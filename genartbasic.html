<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alternate Universe VisionX</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #visionx-frame {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border: none;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <iframe id="visionx-frame" src="https://embed.pickaxeproject.com/axe?id=VisionX_67B29&mode=embed_gold&host=beta&theme=custom&opacity=100&font_header=Libre+Franklin&size_header=32&font_body=Quicksand&size_body=16&font_labels=Quicksand&size_labels=20&font_button=Quicksand&size_button=16&c_fb=040101&c_ff=01070E&c_fbd=FFFFFF&c_rb=019FEF&c_bb=FFFFFF&c_bt=000000&c_t=FFFFFF&s_ffo=100&s_rbo=100&s_bbo=100&s_f=minimalist&s_b=filled&s_t=0.5&s_to=1&s_r=3"></iframe>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);

        // Cosmic background
        const textureLoader = new THREE.TextureLoader();
        const bgTexture = textureLoader.load('https://images.unsplash.com/photo-1451187580459-43490279c0fa?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2072&q=80');
        scene.background = bgTexture;

        // Nebula
        const nebulaGeometry = new THREE.SphereGeometry(5, 32, 32);
        const nebulaMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                
                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);
                }
                
                void main() {
                    vec2 uv = vUv * 2.0 - 1.0;
                    float t = time * 0.1;
                    
                    float r = length(uv);
                    float theta = atan(uv.y, uv.x);
                    
                    float color = 0.0;
                    for(float i = 0.0; i < 3.0; i++) {
                        float n = noise(vec3(r * 10.0 + i * 5.0 + t, theta * 5.0, t * 0.5));
                        color += n * (1.0 - r) * 0.3;
                    }
                    
                    gl_FragColor = vec4(color * 0.5, color, color * 1.5, 1.0);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);

        // Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.02 });
        const starsVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000);
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // Floating crystals
        const crystalGeometry = new THREE.OctahedronGeometry(0.1);
        const crystalMaterial = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100 });
        const crystals = new THREE.Group();
        for (let i = 0; i < 100; i++) {
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            crystal.position.set(
                THREE.MathUtils.randFloatSpread(10),
                THREE.MathUtils.randFloatSpread(10),
                THREE.MathUtils.randFloatSpread(10)
            );
            crystals.add(crystal);
        }
        scene.add(crystals);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(0, 0, 10);
        scene.add(pointLight);

        camera.position.z = 5;

        // Animation loop
        function animate(time) {
            requestAnimationFrame(animate);

            nebula.material.uniforms.time.value = time * 0.001;
            nebula.rotation.y += 0.001;
            starField.rotation.y += 0.0002;
            crystals.rotation.y += 0.001;
            crystals.children.forEach(crystal => {
                crystal.rotation.x += 0.01;
                crystal.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

        animate();

        // Responsive design
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
