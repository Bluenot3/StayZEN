<html><head><base href="https://zenai.biz/legal/" />
<title>ZEN Legal | Official Legal Notices</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<style>
  body, html {
    margin: 0;
    padding: 0;
    font-family: 'Arial', sans-serif;
    background-color: #000;
    color: #fff;
    overflow-x: hidden;
  }
  #canvas-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
  }
  #content {
    position: relative;
    z-index: 1;
    padding: 40px;
    max-width: 800px;
    margin: 20px auto;
    background-color: rgba(0, 0, 0, 0.8);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    border-radius: 15px;
  }
  h1, h2 {
    color: #00ffff;
    text-align: center;
    text-shadow: 0 0 15px #00ffff;
  }
  h1 {
    font-size: 4em;
    margin-bottom: 0.5em;
    text-transform: uppercase;
    letter-spacing: 5px;
  }
  h2 {
    font-size: 2.8em;
    margin-top: 1.5em;
    border-bottom: 3px solid #00ffff;
    padding-bottom: 15px;
  }
  h3 {
    color: #00ffff;
    font-size: 2em;
    margin-top: 1.5em;
  }
  p, ul {
    line-height: 1.9;
    font-size: 1.2em;
  }
  ul {
    padding-left: 25px;
  }
  .section {
    margin-bottom: 50px;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.5s, transform 0.5s;
  }
  .section.visible {
    opacity: 1;
    transform: translateY(0);
  }
  .highlight {
    background-color: #00ffff;
    color: #000;
    padding: 8px 15px;
    border-radius: 8px;
    font-weight: bold;
    display: inline-block;
    margin-top: 10px;
  }
  #info {
    position: absolute;
    top: 20px;
    width: 100%;
    color: #fff;
    text-align: center;
    font-size: 1.4em;
    text-shadow: 0 0 8px #00ffff;
  }
</style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="info">ZEN - Revolutionizing AI Integration</div>
  <div id="content">
    <h1>ZEN Legal</h1>

    <div class="section">
      <h2>Legal Notices</h2>
      <h3>Registered Agent Information</h3>
      <p>
        Republic Registered Agent LLC<br>
        239 Fourth Ave, Ste 1401<br>
        Pittsburgh, PA 15222<br>
        USA
      </p>
    </div>

    <div class="section">
      <h2>Terms and Conditions</h2>
      <p>Welcome to the ZEN website. By accessing or using our website, you agree to comply with and be bound by the following terms and conditions. If you do not agree to these terms, please do not use our website.</p>
      <ul>
        <li><strong>Use of Website:</strong> You may use our website only for lawful purposes and in accordance with these terms.</li>
        <li><strong>Intellectual Property:</strong> All content on our website, including text, graphics, logos, and images, is the property of ZEN and protected by copyright laws.</li>
        <li><strong>Disclaimer of Warranties:</strong> Our website is provided "as is" without any warranties of any kind.</li>
        <li><strong>Limitation of Liability:</strong> ZEN shall not be liable for any damages arising from the use or inability to use our website.</li>
      </ul>
    </div>

    <div class="section">
      <h2>Privacy Policy</h2>
      <p>At ZEN, we respect your privacy and are committed to protecting your personal information. This policy outlines our practices regarding the collection, use, and disclosure of your information.</p>
      <ul>
        <li><strong>Information Collection:</strong> We may collect personal information such as your name, email address, and phone number when you contact us or sign up for our services.</li>
        <li><strong>Use of Information:</strong> We use the information to provide and improve our services, communicate with you, and comply with legal obligations.</li>
        <li><strong>Data Protection:</strong> We implement security measures to protect your information from unauthorized access and disclosure.</li>
        <li><strong>Third-Party Disclosure:</strong> We do not sell or trade your personal information to third parties.</li>
      </ul>
    </div>

    <div class="section">
      <h2>Cookie Policy</h2>
      <p>Our website uses cookies to enhance your browsing experience and analyze our traffic. By using our website, you consent to our use of cookies.</p>
      <ul>
        <li><strong>What Are Cookies?:</strong> Cookies are small text files stored on your device when you visit a website.</li>
        <li><strong>Types of Cookies:</strong> We use both session cookies (which expire when you close your browser) and persistent cookies (which remain on your device until deleted).</li>
        <li><strong>Managing Cookies:</strong> You can manage or disable cookies through your browser settings, but this may affect the functionality of our website.</li>
      </ul>
    </div>

    <div class="section">
      <h2>Contact Information</h2>
      <p>If you have any questions or concerns about our legal notices, please contact us at:</p>
      <p class="highlight">Email: support@zenai.biz</p>
    </div>
  </div>

  <script>
    let scene, camera, renderer, particles, textMesh, composer;
    const particleCount = 30000;

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Particle system
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        colors[i] = Math.random();
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      // Text
      const loader = new THREE.FontLoader();
      loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
        const textGeometry = new THREE.TextGeometry('ZEN', {
          font: font,
          size: 15,
          height: 3,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.2,
          bevelSize: 0.2,
          bevelOffset: 0,
          bevelSegments: 5
        });
        
        const textMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          emissive: 0x00ffff,
          specular: 0x00ffff,
          shininess: 100
        });
        
        textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(-20, 0, 0);
        scene.add(textMesh);
      });

      // Lights
      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 1, 100);
      pointLight.position.set(0, 0, 50);
      scene.add(pointLight);

      // Add digital circuit lines
      addDigitalCircuit();

      animate();
    }

    function addDigitalCircuit() {
      const circuitGeometry = new THREE.BufferGeometry();
      const circuitPositions = [];
      const circuitColors = [];

      for (let i = 0; i < 150; i++) {
        const x = (Math.random() - 0.5) * 100;
        const y = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;

        circuitPositions.push(x, y, z);
        circuitPositions.push(x + (Math.random() - 0.5) * 30, y + (Math.random() - 0.5) * 30, z + (Math.random() - 0.5) * 30);

        const color = new THREE.Color(0x00ffff);
        circuitColors.push(color.r, color.g, color.b);
        circuitColors.push(color.r, color.g, color.b);
      }

      circuitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(circuitPositions, 3));
      circuitGeometry.setAttribute('color', new THREE.Float32BufferAttribute(circuitColors, 3));

      const circuitMaterial = new THREE.LineBasicMaterial({ vertexColors: true, blending: THREE.AdditiveBlending });
      const circuitMesh = new THREE.LineSegments(circuitGeometry, circuitMaterial);
      scene.add(circuitMesh);

      // Animate circuit lines
      gsap.to(circuitMesh.rotation, {
        x: Math.PI * 2,
        y: Math.PI * 2,
        duration: 120,
        repeat: -1,
        ease: "none"
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;
      particles.rotation.x = time * 0.05;
      particles.rotation.y = time * 0.1;

      const positions = particles.geometry.attributes.position.array;
      const colors = particles.geometry.attributes.color.array;

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        positions[i3 + 1] = Math.sin(time + positions[i3]) * 3;
        colors[i3] = Math.sin(time) * 0.5 + 0.5;
        colors[i3 + 1] = Math.sin(time + 2) * 0.5 + 0.5;
        colors[i3 + 2] = Math.sin(time + 4) * 0.5 + 0.5;
      }

      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;

      if (textMesh) {
        textMesh.rotation.y = Math.sin(time * 0.3) * 0.1;
        textMesh.position.y = Math.sin(time * 0.5) * 2;
      }

      renderer.render(scene, camera);
    }

    init();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Intersection Observer for section animations
    const sections = document.querySelectorAll('.section');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 });

    sections.forEach(section => {
      observer.observe(section);
    });
  </script>
</body>
</html>
